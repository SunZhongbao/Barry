#!/usr/bin/env bash

set -e

if test "$DEBUG" = true; then
    set -x
fi
if test "$PWD" = ~; then
    cd ~/system-config/
fi

cd -P .
# cd $(dirname $(lookup-file -e .git))
if test -x .before-gia-hook; then
    ./.before-gia-hook
fi

function die() {
    echo Error: "$@"
    exit -1
}

if ! is-tty-io; then
    die "Can't do it in non tty env"
fi


## start code-generator "^\\s *#\\s *"
    # generate-getopt r:revision \
        # Skeep-it-simple '?"不要显示太多问题，用于代码review"' \
        # b:review-base sselective-review=true odups-only '?"只检查重复提交的文件。必须与 REVISION 合用"'
## end code-generator
## start generated code
TEMP=$( getopt -o oSb:r:sh \
               --long dups-only,keep-it-simple,review-base:,revision:,selective-review,help,no-dups-only,no-keep-it-simple,no-selective-review \
               -n "$(basename -- "$0")" -- "$@")
declare dups_only=false
declare keep_it_simple=false
declare review_base=
declare revision=
declare selective_review=true
eval set -- "$TEMP"
while true; do
    case "$1" in

        -o|--dups-only|--no-dups-only)
            if test "$1" = --no-dups-only; then
                dups_only=false
            else
                dups_only=true
            fi
            shift

            ;;
        -S|--keep-it-simple|--no-keep-it-simple)
            if test "$1" = --no-keep-it-simple; then
                keep_it_simple=false
            else
                keep_it_simple=true
            fi
            shift

            ;;
        -b|--review-base)
            review_base=$2
            shift 2

            ;;
        -r|--revision)
            revision=$2
            shift 2

            ;;
        -s|--selective-review|--no-selective-review)
            if test "$1" = --no-selective-review; then
                selective_review=false
            else
                selective_review=true
            fi
            shift

            ;;
        -h|--help)
            set +x
            echo -e
            echo
            echo Options and arguments:
            printf %6s '-o, '
            printf %-24s '--[no-]dups-only'
            echo "只检查重复提交的文件。必须与 REVISION 合用"
            printf %6s '-S, '
            printf %-24s '--[no-]keep-it-simple'
            echo "不要显示太多问题，用于代码review"
            printf %6s '-b, '
            printf %-24s '--review-base=REVIEW_BASE'
            echo
            printf %6s '-r, '
            printf %-24s '--revision=REVISION'
            echo
            printf %6s '-s, '
            printf %-24s '--[no-]selective-review'
            echo
            exit
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            die "internal error: $(. bt; echo; bt | indent-stdin)"
            ;;
    esac
done


## end generated code

if test -e .git-interactive-add.before; then
    bash .git-interactive-add.before
fi

if test "${dups_only}" = true; then
    if test -z "${revision}"; then
        die "Must specify which revision to compare with!"
    fi

    if ! git-is-clean -r "HEAD"; then
        die "git not clean!"
    fi

    if test $# -gt 0; then
        die "Must not specify any args: $*"
    fi
    set -- $(git log --name-only  ${revision}..HEAD --pretty=''|perl -ne 'print if $a{$_}++' |sort -u)
    if test $# = 0; then
        echo "Every file has only 1 commit, good!"
        exit 0
    fi
fi

function git-diff() {
    clear

    if git status -s "$@" | grep -q -P -e '^\?\?'; then
        if test -f "$1"; then
            read -e -p "$* seems to be a new file, press Enter to continue...  "
            diff /dev/null "$@" || true
        fi
    else
        if test "${revision}" && git diff --quiet HEAD -- "$@"; then
            # 当前代码没有改动，指定了 revision，需要详细 review
            LESS="RSX" git log -w -p "${revision}"..HEAD "$@" || true

            for rev in $(git log --pretty=%H "${revision}"..HEAD "$@"); do
                if test "${keep_it_simple}" = false; then
                    LESS="RSX" git log --name-status -1 $rev || true
                    if yes-or-no-p -y "show details?"; then
                        LESS="RSX" git log -w -p -1 $rev || true
                    fi
                fi
            done
            if test "${keep_it_simple}" = false && yes-or-no-p -n "start new shell for $*"?; then
                export gia_rev=${revision}
                export gia_file="$*"
                start_recursive_shell "$*"
            fi
        elif git diff -w $review_base $revision -- "$@" | grep -q .; then
            git diff -w $review_base $revision -- "$@" || true
        else
            read -e -p "$* seems contain only whitespace changes, press Enter to continue...  "
        fi
    fi
}

function git-meld() {
    clear

    if git status -s "$@" | grep -q -P -e '^\?\?'; then
        read -e -p "$*n seems to be a new file, press Enter to continue...  "
        diff /dev/null "$@"
    else
        git difftool -t meld -y $review_base $revision -- "$@"
        return 0
    fi
}

git-interactive-review-1() {
    local x=$1
    if test "${x:0:1}" = \"; then
        eval x=\$\'"$x"\'
        x=${x#\"}
        x=${x%\"}
    fi
    if test -d "$x"; then
        return
    fi
    if test ! -e "$x" && git status -s |grep -P -e "\Q$x\E" | grep "^RM"; then
        x=$(git status -s |grep -P -e "\Q$x\E" | grep "^RM" | perl -npe 's/.*-> //')
    fi
    if test ! -e "$x" && git status -s "$x" | grep -P -e '^ D|^D' && yes-or-no-p "$x removed, remove it from git?"; then
        git rm "$x"
        return
    fi
    git-diff "$x";

    declare -A gia_options
    gia_options[yes]="yes     (accept this change, do git add)"
    gia_options[no]="no      (do not accept this change, do nothing)"
    gia_options[discard]="discard (discard the change)"
    gia_options[diff]="diff    (show diff again)"
    gia_options[meld]="meld    (check the patch with meld)"
    gia_options[delete]="delete  (delete this file)"
    gia_options[edit]="edit    (open it with my editor)"

    declare -a select_args=(
        "${gia_options[yes]}"
        "${gia_options[no]}"
        "${gia_options[discard]}"
        "${gia_options[diff]}"
        "${gia_options[meld]}"
        "${gia_options[delete]}"
        "${gia_options[edit]}"
    )

    if test "${revision}"; then
        gia_options[history]="history   (显示其从 ${revision} 的变更历史)"
        select_args+=("${gia_options[history]}")
    fi



    while true; do
        out=$(select-args -p "What do you want to do with this file?" \
                          "${select_args[@]}" \
                          "@       $PWD/$x "
           );
        if test "$out" = "${gia_options[diff]}"; then
            git-diff "$x";
            continue;
        fi

        if test "$out" = "${gia_options[meld]}"; then
            git-meld "$x";
            continue
        fi

        if test "$out" = "${gia_options[delete]}"; then
            rm "$x"
            break
        fi

        if test "${out}" = "${gia_options[history]}"; then
            LESS="RSX" git log -p "${revision}"..HEAD "$x"
            continue
        fi

        if test "$out" = "${gia_options[edit]}"; then
            ew "$x"
            find-or-exec konsole
            if test ! -e "$x"; then
                break
            fi
            git-diff "$x";
            continue
        fi

        if test "$out" = "${gia_options[no]}"; then
            break
        fi

        if test "$out" = "${gia_options[discard]}"; then
            git checkout $revision "$x"
            break
        fi

        done_add=false
        if test "$out" = "${gia_options[yes]}"; then
            if test -z "$revision"; then
                git add "$x"
            fi
            done_add=true
        elif test "${out:0:1}" = '!'; then
            hint "Will run ${out#\!} for you, but may be you can simply use 'discard'"
            eval ${out#\!}
        elif test "${out:0:1}" != @; then
            git add "$x"
            done_add=true
            echo $(gitp "$x"): $out >> $(lookup-file-dir -e .git)/.commit-msg-bhj
        fi

        if test "$done_add" = true; then
            if [[ $x =~ \.org$ ]] && grep 'BEGIN_SRC.*:tangle ' -i "$x" -q; then
                (
                    tangle_target=$(grep -o ':tangle\s+\S+\s+' -P "$x" -i |pn 2)
                    tangle_target=$(expand-file-name "$tangle_target")
                    if test -e "$tangle_target" -a "$x" -nt "$tangle_target" && yes-or-no-p -y "Your .org knuth-mode file newer than tangled version, export?"; then
                        emacsclient -e '(progn (find-file "'"$x"'") (org-babel-tangle))'
                        git-interactive-add "$x"
                    fi
                )
            elif test -f "$x" && grep -q '^# sc-after-save-hook: ' "$x"; then
                (
                    bash_command=$(perl -ne 'print $1 if m/^# sc-after-save-hook: (.*)/' "$x");
                    if yes-or-no-p -n "run: '$bash_command' ? "; then
                        cd "$(dirname "$x")"
                        bash -c "$bash_command"
                        git-interactive-add
                    fi
                )
            fi

            git-mark-need-merge
        fi
        break
    done
}

IFS=$'\n'

list_of_files=(
    "$@" $(
        if test $# == 0; then
            if test "$revision" = ""; then
                git status -uall -s .|grep '^.\S' -P | cut -b 4-;
            else
                gitp=$(gitp .)
                case "$gitp" in
                    ./)
                        gitp=
                        ;;
                    *)
                        gitp=$gitp/
                        ;;
                esac
                len=${#gitp}
                start=$((9 + len))
                git diff --name-status $review_base $revision . | expand | cut -b $start-;
            fi
        fi
        )
)

if test "$selective_review" = true; then
    saved_list_of_files=(
        "${list_of_files[@]}"
    )
    while true; do
        special_menu="其他菜单选项"
        if test "${#list_of_files[@]}" = 0; then
            break
        fi
        x=$(
            select-args -a "$special_menu"  -p "请选择要 review 哪个文件" "${list_of_files[@]}"
         )

        if test "$x" = "$special_menu"; then
            declare -A special_ops
            special_ops[quit]="quit：退出 Review"
            special_ops[all]="show-all：重新显示完整文件列表"
            special_ops[back]="back：按错了，返回继续"
            special_ops[shell]="shell：启动一个子 shell，让我执行一些命令"
            x=$(
                select-args -p "请选择你想要执行的操作" "${special_ops[quit]}" "${special_ops[all]}" "${special_ops[back]}" "${special_ops[shell]}"
             )
            if test "$x" = "${special_ops[all]}"; then
                list_of_files=(
                    "${saved_list_of_files[@]}"
                )
                continue
            elif test "$x" = "${special_ops[quit]}"; then
                break
            elif test "$x" = "${special_ops[back]}"; then
                continue
            elif test "$x" = "${special_ops[shell]}"; then
                bash || true
                continue
            else
                hint "未知输入，请正确选择上述选项"
                continue
            fi
        fi

        list_of_files=(
            $(
                for f in "${list_of_files[@]}"; do
                    if test "$x" = "$f"; then
                        continue
                    fi
                    echo "$f"
                done
            )
        )
        git-interactive-review-1 "$x"
    done
else
    for x in "${list_of_files[@]}"; do
        git-interactive-review-1 "$x"
    done
fi

if test -e .before-push-hook -a "$before_push_hook" != done; then
    bash .before-push-hook
    if ! git-is-clean; then
        before_push_hook=done git-interactive-add
    fi
fi
