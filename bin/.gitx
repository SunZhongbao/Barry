#!/usr/bin/env bash
if test -z "$SSH_AUTH_SOCK" -a -e ~/.config/system-config/ssh-agent; then
    . ~/system-config/bin/set-ssh-agent
fi

function git_svn() {
    if test $# = 1; then
        should_return=1
        case "$1" in
            fetch)
                command git svn fetch
                ;;
            pull)
                command git svn rebase
                ;;
            push)
                command git svn dcommit
                ;;
            *)
                should_return=0
                ;;
        esac
        if test $should_return = 1; then
            return
        fi
    fi

    case "$1" in
        st)
            shift
            set -- status "$@"
            NO_SVN_CHECK=true git "$@"
            return;
            ;;
        pull)
            if test $# = 2 -a "$2" = --rebase; then
                command git svn rebase
                return
            fi
            ;;
        push)
            if test "$2" = origin; then
                command git svn dcommit
                return
            fi
            ;;
        diff)
            args=()
            for x in "$@"; do
                if test "$x" = origin/master; then
                    x=git-svn
                fi
                args=("${args[@]}" "$x")
            done
            set -- "${args[@]}"
            command git "$@"
            return
            ;;
    esac
    NO_SVN_CHECK=true git "$@"
}

function git()
{
    local using_st=false

    if test "$1" = st; then
        using_st=true
    fi

    if test $# = 1 -a "$1" = diff; then
        set -- diff -w
    fi

    if test "$1" = export; then
        command git archive --output "$3" "$2"
        return $?
    fi

    if test $# = 1 -a "$1" = cherry-pick; then
        set -- cherry-pick $(select-output-line 'git reflog | head -n 20' | pn 1)
    fi

    if test "$NO_SVN_CHECK" != true && command git config svn-remote.svn.url | grep -q .; then
        git_svn "$@"
        return $?
    fi

    (
        builtin cd -P .
        if test "$(readlink -f .)" = "$(readlink -f ~)" -a "$1" != clone ||
            test "$(readlink -f .)" = "$(readlink -f ~/system-config/)"
        then
            builtin cd ~/system-config/;
            if test "$1" = st -o "$using_st" = true && test "$2" != -S; then
                for x in ~/src/github/*; do
                    if test -d $x -a -e $x/.git; then
                        (
                            builtin cd $x
                            if test ! -e .git/sc-not-merged; then
                                exit 0
                            fi

                            y=$(
                                if test -e .git-status-filter; then
                                    command git status -s | ./.git-status-filter
                                else
                                    command git status -s
                                fi 2>&1
                             )
                            if test "$y"; then
                                echo $x not clean 1>&2
                                command git status -s 2>&1
                                echo ---------------- 1>&2
                                if test "${giti}" = true; then
                                    (
                                        myscr -n "${x##*/}" -w bash -c "hint $x not clean; cd $x; bash"
                                    )
                                fi
                                exit 0
                            fi
                            y=$(
                                command git diff --name-status $(git-remote-branch) 2>&1|
                                    if test -e .git-status-filter; then
                                        ./.git-status-filter
                                    else
                                        cat
                                    fi
                             )
                            if test "$y"; then
                                echo $x not clean with $(git-remote-branch) 1>&2
                                command git diff --name-status $(git-remote-branch) 2>&1
                                echo ---------------- 1>&2
                                if test "${giti}" = true; then
                                    (
                                        myscr -n "${x##*/}" -w bash -c "hint $x not clean; cd $x; bash"
                                    )
                                fi
                            fi
                        )
                    fi
                done
            fi

            if test "$1" = submodule -a "$2" = foreach ||
               test "$1" = submodule -a "$2" = --quiet -a "$3" = foreach; then
                for x in ~/src/github/*; do
                    if test -d $x -a -d $x/.git; then
                        (
                            builtin cd $x
                            while test "$1" != foreach; do
                                shift
                            done
                            shift # foreach
                            if test $# = 1; then
                                bash -c "$1"
                            else
                                "$@"
                            fi
                        )
                    fi
                done
                # still need to do the submodules of system-config
                # although we have no submodules really

                while test "$1" != foreach; do
                    shift
                done
                shift # foreach
                if test "$#" = 1 && [[ "$1" =~ ' ' ]]; then
                    set -- bash -c "$1"
                fi
                set -- submodule --quiet foreach "$@"
            fi
        fi

        if test "$1" = st -a "$2" = -S; then
            command git status -s | perl -ne '
chomp();
if (m/^..."/) {
    s/(".*?")/eval($1)/ge;
}
print $_ . "\n";
'
          exit
        fi
        if test "$1" = clean; then
            where=
            if test $# = 2 -o $# = 1; then
                where=.
            fi
            if command git status -s $where | grep '??'; then
                echo Warning: git not clean, will not clean it
                if yes-or-no-p -n "Continue?"; then
                    true;
                else
                    echo Please use: command git clean -xfd
                    exit -1
                fi
            fi
        fi
        if test $# = 1 -a "$1" = co; then
            git checkout "$(select-output-line 'git reflog | head -n 20' | pn 1)"
            exit
        fi

        if test "$1" = log && test -e $(lookup-file -e .git/)/shallow >/dev/null 2>&1; then
            . atexit hint -t .5 "你的 git 是个 shallow 仓储，git log 可能显示不全，可能需要运行 sse unshallow"
        fi

        if test "$#" = 1 -a "$1" = reset-files-to-rev; then
            x=$(select-output-line 'git reflog | head -n 20' | pn 1)
            git ls-tree --name-only HEAD | xargs -d \\n git rm -rf
            git checkout "$x" -- .
            git commit -m "$(git log --pretty="%B" "$x" -1)"
            exit
        fi

        # git co -B
        if test "$2" = -t && test "$1" = co -o "$1" = checkout; then
            if test "$#" = 2; then
                git checkout "$(select-output-line git tag)"
                exit
            fi
        fi
        if test "$2" = -B && test "$1" = co -o "$1" = checkout; then
            if test "$#" = 2; then
                git checkout -B "$(git-choose-branch remotes/ )"
                exit
            elif test "$#" = 3; then
                echo git checkout -B $(echo $3|perl -npe 's!^remotes/!!; s!^[^/]+/!!') $3
                git checkout -B $(echo $3|perl -npe 's!^remotes/!!; s!^[^/]+/!!') $3
                exit
            fi
        fi

        if test "$1" = co -a $# = 2; then
            set -- checkout "$2"
            command git "$@" || {
                git fetch -v $(repo-remote) || true
                git checkout $(git-choose-branch "$2")
            }
            exit
        fi

        if test "$1" = fetch && test $# = 1 -o $# = 2 -a "$2" = -v; then
            shift
            command git fetch "$@" $(select-output-line -o -m 1 git remote)
            exit
        elif test "$1" = fetch -a "$#" -ge 2; then
            if [[ "$*" =~ " -a" ]]; then
                shift 2
                set -- "fetch" -v "$@"
                for remote in $(command git remote); do
                    command git config remote.$remote.fetch "+refs/heads/*:refs/remotes/$remote/*"
                done
            elif test "$2" = \?; then
                shift 2
                set -- "fetch" $(git-choose-branch) "$@"
            fi
            if [[ "$2" =~ ^remotes/ ]]; then
                remote=$(echo "$2" | perl -npe 's!remotes/!!; s!/.*!!')
                branch=$(echo "$2" | perl -npe 's!remotes/.*?/!!;')
                command git fetch $remote $branch:$branch
                exit
            fi
        elif test "$1" = st; then
            shift
            set -- status "$@"
        elif test "$1" = co; then
            shift
            set -- checkout "$@"
        elif test "$1" = dt; then
            shift
            set -- difftool -t meld "$@"
        fi
        if test "$1" = push -a $# = 1 && lookup-file -e .repo/manifest.xml >/dev/null 2>&1; then
            head_branch=$(git symbolic-ref --short HEAD 2>/dev/null || true)

            if test -z "$head_branch"; then
                command git push $(repo-remote) HEAD:$(repo-branch)
                exit
            elif [[ $PWD =~ /.repo/manifests$ ]]; then
                command git push $(repo-remote) HEAD:$(repo-remote-branch|perl -npe 's,.*?/,,')
                exit
            fi
        fi

        if test "$1" = pull; then
            if test -e ~/src/github/smartcm/scm-helpers/git-pull-and-review; then
                . ~/src/github/smartcm/scm-helpers/git-pull-and-review
            fi
            if test $# = 1; then
               head_branch=$(git symbolic-ref --short HEAD 2>/dev/null || true)
               if test -z "$head_branch" && lookup-file -e .repo/manifest.xml >/dev/null 2>&1; then
                   command git checkout -B $(repo-branch) $(repo-remote)/$(repo-branch)
               fi
               if test ! -z "$head_branch"; then
                   set -- pull $(repo-remote) $(repo-branch)
               fi
           fi
        fi
        command git "$@"
    )
}
